import type { GenerateSchema } from 'payload'

import { execSync } from 'child_process'
import { existsSync } from 'fs'
import { readFile, rm, writeFile } from 'fs/promises'
import { createRequire } from 'module'
import os from 'os'
import path from 'path'
import { v4 as uuid } from 'uuid'

import type { DrizzleAdapter } from '../types.js'

const url = import.meta.url

const require = createRequire(url)

const drizzleBinPath = path.resolve(path.dirname(require.resolve('drizzle-kit')), 'bin.cjs')

/**
 *
 */
const formatedFile = (packageName: string, content: string) => {
  let formatted = ''

  const imports = []
  const exports = []

  let pgView = false

  for (const line of content.split('\n')) {
    // SKIP pgView generation
    if (pgView) {
      if (line === '') {
        pgView = false
      } else {
        continue
      }
    }

    if (line.includes('pgView(')) {
      pgView = true
      continue
    }

    if (line.startsWith('import')) {
      // skip import of schema from relations
      if (!line.includes(`"./schema"`)) {
        // replace with the proxy path
        imports.push(line.replace(`"drizzle-orm`, `"${packageName}/drizzle`))
      }
      continue
    }

    // collect all exports to include to declaration later
    if (line.startsWith('export const')) {
      const [_, afterExport] = line.split('export const ')
      const [exportName] = afterExport.split(' =')
      exports.push(exportName)
    }

    let formattedLine = line

    // Drizzle typescript bug with default values and point field
    if (line.includes(`geometry({ type: "point" }).default`)) {
      const [firstChunk, secondChunk] = line.split('.default(')

      const formattedSecondChunk = `sql.raw(${secondChunk.slice(0, secondChunk.length - 1)}),`
      formattedLine = `${firstChunk}.default(${formattedSecondChunk}`
    }

    formatted += `${formattedLine}\n`
  }

  return `
/* tslint:disable */
/* eslint-disable */
/**
 * This file was automatically generated by Payload.
 * DO NOT MODIFY IT BY HAND. Instead, modify your source Payload config,
 * and re-run \`payload generate:db-schema\` to regenerate this file.
 */
${imports.join('\n')}
${formatted}

export type DatabaseSchema = {
${exports.map((exportName) => `  ${exportName}: typeof ${exportName}`).join('\n')}
}

declare module "${packageName}/types" {
    export interface GeneratedDatabaseSchema {
      schema: DatabaseSchema
    }
}

`
}

export const createSchemaGenerator = ({
  defaultOutputFile,
  dialect,
  schemaFilter,
  url,
}: {
  defaultOutputFile?: string
  dialect: string
  schemaFilter?: string
  url: string
}): GenerateSchema => {
  return async function generateSchema(
    this: DrizzleAdapter,
    { outputFile = defaultOutputFile } = {},
  ) {
    const tempDir = path.resolve(os.tmpdir(), uuid())

    const hasPostgis = Boolean((this as any).extensions?.postgis)

    const drizzleArgs = {
      dialect,
      out: tempDir,
      schemaFilter,
      tablesFilter: hasPostgis ? '!spatial_ref_sys' : undefined,
      url,
    }

    const command = Object.entries(drizzleArgs)
      .reduce(
        (acc, [key, value]) => {
          if (value) {
            acc.push(`--${key}=${value}`)
          }
          return acc
        },
        ['node', drizzleBinPath, 'pull'],
      )
      .join(' ')

    execSync(command, { stdio: 'inherit' })

    this.payload.logger.info('Post processing...')

    const [schema, relationships] = await Promise.all([
      readFile(path.resolve(tempDir, 'schema.ts'), 'utf-8'),
      readFile(path.resolve(tempDir, 'relations.ts'), 'utf-8'),
    ])

    await rm(tempDir, { force: true, recursive: true })

    const output = formatedFile(
      this.packageName,
      `
${schema}

${relationships}
`,
    )

    if (!outputFile) {
      const cwd = process.cwd()
      const srcDir = path.resolve(cwd, 'src')
      if (existsSync(srcDir)) {
        outputFile = path.resolve(srcDir, 'payload-generated-schema.ts')
      } else {
        outputFile = path.resolve(cwd, 'payload-generated-schema.ts')
      }
    }

    await writeFile(outputFile, output, {
      encoding: 'utf-8',
      flag: 'w',
    })

    this.payload.logger.info(`Finished, written ${outputFile}`)
  }
}
