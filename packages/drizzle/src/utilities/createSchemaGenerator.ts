import type { GenerateSchema } from 'payload'

import { execSync } from 'child_process'
import { existsSync } from 'fs'
import { mkdir, readFile, rm, writeFile } from 'fs/promises'
import { createRequire } from 'module'
import os from 'os'
import path from 'path'
import { v4 as uuid } from 'uuid'

import type { DrizzleAdapter } from '../types.js'

const url = import.meta.url

const require = createRequire(url)

const drizzleKitPath = require.resolve('drizzle-kit')

const drizzleBinPath = path.resolve(path.dirname(drizzleKitPath), 'bin.cjs')

const formatSchemaFile = (packageName: string, content: string) => {
  let formatted = ''

  const imports = []
  const exports = []

  for (const line of content.split('\n')) {
    if (line.trim().startsWith('import')) {
      // skip import of schema from relations
      if (!line.includes(`"./schema"`)) {
        // replace with the proxy path
        imports.push(line.replace(`"drizzle-orm`, `"${packageName}/drizzle`))
      }
      continue
    }

    // collect all exports to include to declaration later
    if (line.startsWith('export const')) {
      const [_, afterExport] = line.split('export const ')
      const [exportName] = afterExport.split(' =')
      exports.push(exportName)
    }

    let formattedLine = line

    // Drizzle typescript bug with default values and point field
    if (line.includes(`geometry({ type: "point" }).default`)) {
      const [firstChunk, secondChunk] = line.split('.default(')

      const formattedSecondChunk = `sql.raw(${secondChunk.slice(0, secondChunk.length - 1)}),`
      formattedLine = `${firstChunk}.default(${formattedSecondChunk}`
    }

    formatted += `${formattedLine}\n`
  }

  return `
/* tslint:disable */
/* eslint-disable */
/**
 * This file was automatically generated by Payload.
 * DO NOT MODIFY IT BY HAND. Instead, modify your source Payload config,
 * and re-run \`payload generate:db-schema\` to regenerate this file.
 */
${imports.join('\n')}
${formatted}

export type DatabaseSchema = {
${exports.map((exportName) => `  ${exportName}: typeof ${exportName}`).join('\n')}
}

declare module "${packageName}/types" {
    export interface GeneratedDatabaseSchema {
      schema: DatabaseSchema
    }
}

`
}

export const createSchemaGenerator = ({
  dbCredentials,
  defaultOutputFile,
  dialect,
}: {
  dbCredentials: Record<string, string>
  defaultOutputFile?: string
  dialect: string
}): GenerateSchema => {
  return async function generateSchema(
    this: DrizzleAdapter,
    { outputFile = defaultOutputFile } = {},
  ) {
    const tempDir = path.resolve(os.tmpdir(), uuid())

    const extensionsFilters = []

    if ('extensions' in this && typeof this.extensions === 'object') {
      for (const extension in this.extensions) {
        if (this.extensions[extension]) {
          extensionsFilters.push(`"${extension}"`)
        }
      }
    }

    const drizzleConfig = `
import { createRequire } from 'module'
const url = import.meta.url
const require = createRequire(url)
const { defineConfig } = require("${drizzleKitPath}")
export default defineConfig({
  dialect: "${dialect}",
  dbCredentials: {
${Object.entries(dbCredentials)
  .filter(([_, val]) => Boolean(val))
  .map(([key, value]) => `    ${key}: "${value}",`)
  .join('\n')}
  },
  out: "${tempDir}",
  ${extensionsFilters.length ? `extensionsFilters: [${extensionsFilters.join(', ')}],` : ''}
  ${this.schemaName ? `schemaFilter: ["${this.schemaName}"],` : ''}
});
`

    const drizzleConfigPath = path.resolve(tempDir, 'drizzle.config.js')

    await mkdir(tempDir, { recursive: true })

    await writeFile(drizzleConfigPath, drizzleConfig, 'utf-8')

    try {
      execSync(`node ${drizzleBinPath} pull --config=${drizzleConfigPath}`, {
        stdio: 'inherit',
      })
    } catch (e) {
      this.payload.logger.error(e)
      throw e
    }

    this.payload.logger.info('Post processing...')

    const [schema, relationships] = await Promise.all([
      readFile(path.resolve(tempDir, 'schema.ts'), 'utf-8'),
      readFile(path.resolve(tempDir, 'relations.ts'), 'utf-8'),
    ])

    await rm(tempDir, { force: true, recursive: true })

    const output = formatSchemaFile(
      this.packageName,
      `
${schema}

${relationships}
`,
    )

    if (!outputFile) {
      const cwd = process.cwd()
      const srcDir = path.resolve(cwd, 'src')
      if (existsSync(srcDir)) {
        outputFile = path.resolve(srcDir, 'payload-generated-schema.ts')
      } else {
        outputFile = path.resolve(cwd, 'payload-generated-schema.ts')
      }
    }

    await writeFile(outputFile, output, {
      encoding: 'utf-8',
      flag: 'w',
    })

    this.payload.logger.info(`Finished, written ${outputFile}`)
  }
}
