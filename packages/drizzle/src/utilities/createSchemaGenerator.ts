import type { GenerateSchema } from 'payload'

import { execSync } from 'child_process'
import { existsSync } from 'fs'
import { mkdir, readFile, rm, writeFile } from 'fs/promises'
import { createRequire } from 'module'
import os from 'os'
import path from 'path'
import ts from 'typescript'
import { v4 as uuid } from 'uuid'

import type { DrizzleAdapter } from '../types.js'

const url = import.meta.url

const require = createRequire(url)

const drizzleKitPath = require.resolve('drizzle-kit')

const drizzleBinPath = path.resolve(path.dirname(drizzleKitPath), 'bin.cjs')

/**
 * Does something similar to your code editor on F2.
 */
const renameTypescriptVariables = (source: string, variablesMap: Map<string, string>): string => {
  const sourceFile = ts.createSourceFile(
    'temp.ts',
    source,
    ts.ScriptTarget.Latest,
    true,
    ts.ScriptKind.TS,
  )

  const transformer = <T extends ts.Node>(context: ts.TransformationContext) => {
    const visit = (node: ts.Node): ts.Node => {
      // Check if the node is an identifier and matches the oldName
      if (ts.isIdentifier(node)) {
        const newName = variablesMap.get(node.text)
        if (newName) {
          return ts.factory.createIdentifier(newName)
        }
      }

      return ts.visitEachChild(node, visit, context)
    }

    return (node: T) => ts.visitNode(node, visit)
  }

  const result = ts.transform(sourceFile, [transformer])
  const printer = ts.createPrinter()

  const transformedSourceFile = result.transformed[0] as ts.SourceFile
  const updatedCode = printer.printFile(transformedSourceFile)

  return updatedCode
}

const formatSchemaFile = (packageName: string, content: string) => {
  let formatted = ''

  const imports = []
  const exports = []

  const renameVariablesMap = new Map<string, string>()

  for (const line of content.split('\n')) {
    if (line.trim().startsWith('import')) {
      // skip import of schema from relations
      if (!line.includes(`"./schema"`)) {
        // replace with the proxy path
        imports.push(line.replace(`"drizzle-orm`, `"${packageName}/drizzle`))
      }
      continue
    }

    // collect all exports to include to declaration later
    if (line.startsWith('export const')) {
      let tableName: null | string = null

      if (line.includes('Table(')) {
        const [_, afterTable] = line.split(`Table("`)
        ;[tableName] = afterTable.split('"')
      } else if (line.includes('table(')) {
        const [_, afterTable] = line.split(`table("`)
        ;[tableName] = afterTable.split('"')
      }

      const [_, afterExport] = line.split('export const ')
      let [exportName] = afterExport.split(' =')

      if (tableName) {
        renameVariablesMap.set(exportName, tableName)

        exportName = tableName
      }

      exports.push(exportName)
    }

    let formattedLine = line

    // Drizzle typescript bug with default values and point field
    if (line.includes(`geometry({ type: "point" }).default`)) {
      const [firstChunk, secondChunk] = line.split('.default(')

      const formattedSecondChunk = `sql.raw(${secondChunk.slice(0, secondChunk.length - 1)}),`
      formattedLine = `${firstChunk}.default(${formattedSecondChunk}`
    }

    formatted += `${formattedLine}\n`
  }

  return renameTypescriptVariables(
    `
/* tslint:disable */
/* eslint-disable */
/**
 * This file was automatically generated by Payload.
 * DO NOT MODIFY IT BY HAND. Instead, modify your source Payload config,
 * and re-run \`payload generate:db-schema\` to regenerate this file.
 */
${imports.join('\n')}
${formatted}

export type DatabaseSchema = {
${exports.map((exportName) => `  ${exportName}: typeof ${exportName}`).join('\n')}
}

declare module "${packageName}/types" {
    export interface GeneratedDatabaseSchema {
      schema: DatabaseSchema
    }
}

`,
    renameVariablesMap,
  )
}

export const createSchemaGenerator = ({
  dbCredentials,
  defaultOutputFile,
  dialect,
}: {
  dbCredentials: Record<string, string>
  defaultOutputFile?: string
  dialect: string
}): GenerateSchema => {
  return async function generateSchema(
    this: DrizzleAdapter,
    { outputFile = defaultOutputFile } = {},
  ) {
    const tempDir = path.resolve(os.tmpdir(), uuid())

    const extensionsFilters = []

    if ('extensions' in this && typeof this.extensions === 'object') {
      for (const extension in this.extensions) {
        if (this.extensions[extension]) {
          extensionsFilters.push(`"${extension}"`)
        }
      }
    }

    const drizzleConfig = `
import { createRequire } from 'module'
const url = import.meta.url
const require = createRequire(url)
const { defineConfig } = require("${drizzleKitPath}")
export default defineConfig({
  dialect: "${dialect}",
  dbCredentials: {
${Object.entries(dbCredentials)
  .filter(([_, val]) => Boolean(val))
  .map(([key, value]) => `    ${key}: "${value}",`)
  .join('\n')}
  },
  out: "${tempDir}",
  ${extensionsFilters.length ? `extensionsFilters: [${extensionsFilters.join(', ')}],` : ''}
  ${this.schemaName ? `schemaFilter: ["${this.schemaName}"],` : ''}
});
`

    const drizzleConfigPath = path.resolve(tempDir, 'drizzle.config.js')

    await mkdir(tempDir, { recursive: true })

    await writeFile(drizzleConfigPath, drizzleConfig, 'utf-8')

    try {
      execSync(`node ${drizzleBinPath} pull --config=${drizzleConfigPath}`, {
        stdio: 'inherit',
      })
    } catch (e) {
      this.payload.logger.error(e)
      throw e
    }

    this.payload.logger.info('Post processing...')

    const [schema] = await Promise.all([
      readFile(path.resolve(tempDir, 'schema.ts'), 'utf-8'),
      /**
       * TODO: revise how we should handle relationships when names are completely different from what drizzle generates and what our "in memory" drizzle has.
       * With tables we name them in formatSchemaFile
       */
      // readFile(path.resolve(tempDir, 'relations.ts'), 'utf-8'),
    ])

    await rm(tempDir, { force: true, recursive: true })

    const output = formatSchemaFile(
      this.packageName,
      `
${schema}
`,
    )

    if (!outputFile) {
      const cwd = process.cwd()
      const srcDir = path.resolve(cwd, 'src')
      if (existsSync(srcDir)) {
        outputFile = path.resolve(srcDir, 'payload-generated-schema.ts')
      } else {
        outputFile = path.resolve(cwd, 'payload-generated-schema.ts')
      }
    }

    await writeFile(outputFile, output, {
      encoding: 'utf-8',
      flag: 'w',
    })

    this.payload.logger.info(`Finished, written ${outputFile}`)
  }
}
